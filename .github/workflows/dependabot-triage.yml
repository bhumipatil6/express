# .github/workflows/dependabot-triage-auto-pr.yml
# Dependabot Security Debt Prioritizer with Auto-PR for Safe Fixes
# 
# Features:
# - ROI-based prioritization
# - Auto-creates PRs for safe updates (patch/minor bumps)
# - Runs tests before creating PR
# - Labels PRs for easy identification and auto-merge

name: Dependabot Triage with Auto-PR

on:
  workflow_dispatch:
    inputs:
      max_alerts:
        description: 'Maximum alerts to process'
        required: false
        default: '50'
      auto_pr_count:
        description: 'Max number of auto-PRs to create'
        required: false
        default: '5'
      dry_run:
        description: 'Dry run - analyze only, no PRs'
        required: false
        default: 'false'
        type: boolean
      min_roi:
        description: 'Minimum ROI score for auto-PR'
        required: false
        default: '100'
  
  schedule:
    - cron: '0 9 * * 1'  # Weekly Monday 9am UTC

env:
  NODE_VERSION: '20'

jobs:
  # ============================================================
  # JOB 1: Analyze and Prioritize Alerts
  # ============================================================
  analyze:
    name: Analyze Dependabot Alerts
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    permissions:
      contents: read
      security-events: read
    
    outputs:
      auto_pr_candidates: ${{ steps.identify-candidates.outputs.candidates }}
      candidate_count: ${{ steps.identify-candidates.outputs.count }}
      total_alerts: ${{ steps.fetch-alerts.outputs.count }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fetch Dependabot Alerts
        id: fetch-alerts
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          echo "ðŸ“¥ Fetching Dependabot alerts..."
          gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/dependabot/alerts?state=open&per_page=${{ inputs.max_alerts || 50 }}" \
            > /tmp/raw_alerts.json
          
          count=$(jq 'length' /tmp/raw_alerts.json)
          echo "count=$count" >> $GITHUB_OUTPUT
          echo "âœ… Found $count open alerts"

      - name: Fetch EPSS Scores
        run: |
          cves=$(jq -r '.[].security_advisory.cve_id // empty' /tmp/raw_alerts.json \
            | sort -u | head -50 | tr '\n' ',' | sed 's/,$//')
          
          if [ -n "$cves" ]; then
            curl -s "https://api.first.org/data/v1/epss?cve=${cves}" > /tmp/epss_raw.json
            jq '[.data[]? | {(.cve): (.epss | tonumber)}] | add // {}' /tmp/epss_raw.json > /tmp/epss_scores.json
          else
            echo '{}' > /tmp/epss_scores.json
          fi

      - name: Calculate ROI and Identify Auto-PR Candidates
        id: identify-candidates
        run: |
          cat << 'PYTHON_SCRIPT' > /tmp/analyze.py
          import json
          import sys
          import re
          
          def load_json(path, default):
              try:
                  with open(path) as f:
                      return json.load(f)
              except:
                  return default
          
          alerts = load_json('/tmp/raw_alerts.json', [])
          epss_scores = load_json('/tmp/epss_scores.json', {})
          
          min_roi = float(sys.argv[1]) if len(sys.argv) > 1 else 100
          max_candidates = int(sys.argv[2]) if len(sys.argv) > 2 else 5
          
          def parse_version(v):
              """Parse semver string to tuple"""
              if not v:
                  return (0, 0, 0)
              match = re.match(r'^(\d+)\.(\d+)\.(\d+)', str(v))
              if match:
                  return tuple(map(int, match.groups()))
              return (0, 0, 0)
          
          def get_update_type(current, patched):
              """Determine if update is patch, minor, or major"""
              if not current or not patched:
                  return 'unknown'
              
              curr = parse_version(current)
              patch = parse_version(patched)
              
              if curr[0] != patch[0]:
                  return 'major'
              elif curr[1] != patch[1]:
                  return 'minor'
              elif curr[2] != patch[2]:
                  return 'patch'
              return 'unknown'
          
          def is_safe_for_auto_pr(alert, update_type):
              """Determine if alert is safe for automatic PR"""
              # Only patch and minor updates are safe
              if update_type not in ['patch', 'minor']:
                  return False
              
              # Must have a patched version
              vuln = alert.get('security_vulnerability', {})
              if not vuln.get('first_patched_version', {}).get('identifier'):
                  return False
              
              # Skip if package ecosystem isn't npm (for now)
              if vuln.get('package', {}).get('ecosystem', '').lower() != 'npm':
                  return False
              
              return True
          
          def calculate_roi(alert):
              advisory = alert.get('security_advisory', {})
              vuln = alert.get('security_vulnerability', {})
              
              cve_id = advisory.get('cve_id', 'N/A')
              severity = advisory.get('severity', 'medium')
              cvss = advisory.get('cvss', {}).get('score', 5.0)
              epss = epss_scores.get(cve_id, 0.1)
              
              # Get version info
              current_version = vuln.get('vulnerable_version_range', '')
              first_patched = vuln.get('first_patched_version', {}).get('identifier', '')
              
              # Simple extraction of current version from range like "< 3.9.8"
              current_match = re.search(r'(\d+\.\d+\.\d+)', current_version)
              current = current_match.group(1) if current_match else ''
              
              update_type = get_update_type(current, first_patched)
              
              # Scope multiplier
              scope = alert.get('dependency', {}).get('scope', 'runtime')
              scope_mult = 3.0 if scope == 'runtime' else 1.5
              
              # Effort based on update type
              effort_map = {'patch': 1, 'minor': 1.5, 'major': 3, 'unknown': 2}
              effort = effort_map.get(update_type, 2)
              
              risk_score = cvss * epss * 100
              roi = (risk_score * scope_mult) / effort
              
              return {
                  'alert_number': alert.get('number'),
                  'package': vuln.get('package', {}).get('name', 'unknown'),
                  'ecosystem': vuln.get('package', {}).get('ecosystem', 'unknown'),
                  'severity': severity,
                  'cve_id': cve_id,
                  'cvss': round(cvss, 1),
                  'epss': round(epss, 4),
                  'roi': round(roi, 2),
                  'current_version': current,
                  'patched_version': first_patched,
                  'update_type': update_type,
                  'safe_for_auto_pr': is_safe_for_auto_pr(alert, update_type),
                  'summary': advisory.get('summary', '')[:100],
                  'html_url': alert.get('html_url', ''),
                  'manifest_path': alert.get('dependency', {}).get('manifest_path', 'package.json')
              }
          
          # Process all alerts
          results = []
          for alert in alerts:
              try:
                  results.append(calculate_roi(alert))
              except Exception as e:
                  print(f"Warning: {e}")
          
          # Sort by ROI
          results.sort(key=lambda x: x['roi'], reverse=True)
          
          # Save all results
          with open('/tmp/prioritized_alerts.json', 'w') as f:
              json.dump(results, f, indent=2)
          
          # Identify auto-PR candidates
          candidates = [
              r for r in results 
              if r['safe_for_auto_pr'] and r['roi'] >= min_roi
          ][:max_candidates]
          
          # Dedupe by package (keep highest ROI for each package)
          seen_packages = set()
          deduped_candidates = []
          for c in candidates:
              if c['package'] not in seen_packages:
                  seen_packages.add(c['package'])
                  deduped_candidates.append(c)
          
          with open('/tmp/auto_pr_candidates.json', 'w') as f:
              json.dump(deduped_candidates, f, indent=2)
          
          print(f"\n{'='*60}")
          print(f"Analysis Complete!")
          print(f"{'='*60}")
          print(f"Total alerts: {len(results)}")
          print(f"Auto-PR candidates: {len(deduped_candidates)}")
          
          for c in deduped_candidates:
              print(f"  âœ“ {c['package']}: {c['current_version']} â†’ {c['patched_version']} ({c['update_type']}) ROI: {c['roi']}")
          PYTHON_SCRIPT
          
          python3 /tmp/analyze.py ${{ inputs.min_roi || 100 }} ${{ inputs.auto_pr_count || 5 }}
          
          # Set outputs
          candidates=$(cat /tmp/auto_pr_candidates.json | jq -c '.')
          count=$(cat /tmp/auto_pr_candidates.json | jq 'length')
          
          echo "candidates=$candidates" >> $GITHUB_OUTPUT
          echo "count=$count" >> $GITHUB_OUTPUT

      - name: Upload Analysis Results
        uses: actions/upload-artifact@v4
        with:
          name: triage-analysis-${{ github.run_number }}
          path: |
            /tmp/prioritized_alerts.json
            /tmp/auto_pr_candidates.json

  # ============================================================
  # JOB 2: Create Auto-PRs for Safe Updates
  # ============================================================
  create-prs:
    name: Create Auto-PRs
    needs: analyze
    if: ${{ needs.analyze.outputs.candidate_count > 0 && inputs.dry_run != 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    permissions:
      contents: write
      pull-requests: write
    
    strategy:
      fail-fast: false
      max-parallel: 1  # Create PRs one at a time to avoid conflicts
      matrix:
        candidate: ${{ fromJson(needs.analyze.outputs.auto_pr_candidates) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          # Note: cache disabled - no lock file in repo

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create Branch and Update Package
        id: update
        run: |
          PACKAGE="${{ matrix.candidate.package }}"
          VERSION="${{ matrix.candidate.patched_version }}"
          ALERT_NUM="${{ matrix.candidate.alert_number }}"
          
          BRANCH_NAME="security/dependabot-${PACKAGE}-${VERSION//\./-}"
          
          echo "ðŸ“¦ Updating $PACKAGE to $VERSION"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          # Check if branch already exists
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "â­ï¸ Branch $BRANCH_NAME already exists, skipping"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Create new branch
          git checkout -b "$BRANCH_NAME"
          
          # Method 1: Direct package.json update (faster, avoids dependency resolution)
          echo "ðŸ“ Updating package.json directly..."
          if command -v jq &> /dev/null; then
            # Update in dependencies
            if jq -e ".dependencies[\"$PACKAGE\"]" package.json > /dev/null 2>&1; then
              jq ".dependencies[\"$PACKAGE\"] = \"$VERSION\"" package.json > package.json.tmp && mv package.json.tmp package.json
              echo "âœ… Updated $PACKAGE in dependencies"
            # Update in devDependencies
            elif jq -e ".devDependencies[\"$PACKAGE\"]" package.json > /dev/null 2>&1; then
              jq ".devDependencies[\"$PACKAGE\"] = \"$VERSION\"" package.json > package.json.tmp && mv package.json.tmp package.json
              echo "âœ… Updated $PACKAGE in devDependencies"
            else
              echo "âš ï¸ Package $PACKAGE not found in package.json, trying npm install..."
              # Fallback to npm install
              if npm install "${PACKAGE}@${VERSION}" --save --legacy-peer-deps --ignore-scripts; then
                echo "âœ… Package installed with npm"
              elif npm install "${PACKAGE}@${VERSION}" --save --force --ignore-scripts; then
                echo "âœ… Package installed with --force"
              else
                echo "âŒ Failed to install package"
                echo "skip=true" >> $GITHUB_OUTPUT
                exit 0
              fi
            fi
          else
            # No jq, use sed (less reliable but works)
            sed -i "s/\"$PACKAGE\": \"[^\"]*\"/\"$PACKAGE\": \"$VERSION\"/" package.json
            echo "âœ… Updated with sed"
          fi
          
          # Check if there are changes
          if git diff --quiet package.json; then
            echo "â­ï¸ No changes detected, skipping"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "skip=false" >> $GITHUB_OUTPUT
          
          # Show the change
          echo "ðŸ“‹ Change made:"
          git diff package.json | head -20

      - name: Run Tests
        id: test
        if: steps.update.outputs.skip != 'true'
        continue-on-error: true
        run: |
          echo "ðŸ§ª Checking if tests can run..."
          
          # Check if test script exists
          if ! jq -e '.scripts.test' package.json > /dev/null 2>&1; then
            echo "âš ï¸ No test script defined, marking as needs-review"
            echo "test_passed=false" >> $GITHUB_OUTPUT
            echo "test_skipped=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Try to install and test (but don't fail the job if it doesn't work)
          echo "ðŸ“¥ Installing dependencies..."
          if npm install --legacy-peer-deps --ignore-scripts 2>/dev/null; then
            echo "âœ… Dependencies installed"
            
            echo "ðŸ§ª Running tests..."
            if npm test 2>/dev/null; then
              echo "test_passed=true" >> $GITHUB_OUTPUT
              echo "âœ… Tests passed"
            else
              echo "test_passed=false" >> $GITHUB_OUTPUT
              echo "âš ï¸ Tests failed"
            fi
          else
            echo "âš ï¸ Could not install dependencies for testing"
            echo "test_passed=false" >> $GITHUB_OUTPUT
            echo "test_skipped=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit and Push
        id: commit
        if: steps.update.outputs.skip != 'true'
        run: |
          PACKAGE="${{ matrix.candidate.package }}"
          VERSION="${{ matrix.candidate.patched_version }}"
          
          # Add package.json (always exists)
          git add package.json
          
          # Add lock file if it exists
          if [ -f package-lock.json ]; then
            git add package-lock.json
          fi
          
          git commit -m "fix(security): update $PACKAGE to $VERSION

          Resolves Dependabot alert #${{ matrix.candidate.alert_number }}
          
          Security Advisory: ${{ matrix.candidate.summary }}
          CVE: ${{ matrix.candidate.cve_id }}
          Severity: ${{ matrix.candidate.severity }}
          ROI Score: ${{ matrix.candidate.roi }}
          
          Auto-generated by Dependabot Triage workflow"
          
          git push origin "${{ steps.update.outputs.branch_name }}"

      - name: Create Pull Request
        if: steps.update.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          PACKAGE="${{ matrix.candidate.package }}"
          VERSION="${{ matrix.candidate.patched_version }}"
          TEST_STATUS="${{ steps.test.outputs.test_passed }}"
          
          # Set labels based on test status
          if [ "$TEST_STATUS" = "true" ]; then
            LABELS="security,auto-pr,tests-passed,safe-to-merge"
            TEST_BADGE="âœ… Tests Passed"
          else
            LABELS="security,auto-pr,needs-review"
            TEST_BADGE="âš ï¸ Tests Need Review"
          fi
          
          # Create PR
          gh pr create \
            --title "ðŸ”’ Security: Update $PACKAGE to $VERSION" \
            --body "## Security Update

          **Package:** \`$PACKAGE\`
          **Update:** \`${{ matrix.candidate.current_version }}\` â†’ \`$VERSION\`
          **Update Type:** ${{ matrix.candidate.update_type }}

          ### Security Details

          | Metric | Value |
          |--------|-------|
          | **CVE** | ${{ matrix.candidate.cve_id }} |
          | **Severity** | ${{ matrix.candidate.severity }} |
          | **CVSS** | ${{ matrix.candidate.cvss }} |
          | **EPSS** | ${{ matrix.candidate.epss }} ($(echo '${{ matrix.candidate.epss }} * 100' | bc)% exploitation probability) |
          | **ROI Score** | ${{ matrix.candidate.roi }} |

          ### Summary
          ${{ matrix.candidate.summary }}

          ### Test Status
          $TEST_BADGE

          ### Links
          - [Dependabot Alert #${{ matrix.candidate.alert_number }}](${{ matrix.candidate.html_url }})

          ---
          *Auto-generated by Dependabot Triage workflow. Review and merge when ready.*
          " \
            --label "$LABELS" \
            --head "${{ steps.update.outputs.branch_name }}" \
            --base main

  # ============================================================
  # JOB 3: Generate Summary Report
  # ============================================================
  summary:
    name: Generate Summary
    needs: [analyze, create-prs]
    if: always()
    runs-on: ubuntu-latest
    
    permissions:
      contents: read

    steps:
      - name: Download Analysis
        uses: actions/download-artifact@v4
        with:
          name: triage-analysis-${{ github.run_number }}
          path: /tmp/

      - name: Generate Summary Report
        run: |
          echo "## ðŸ”’ Dependabot Triage Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Repository:** ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "**Run Date:** $(date -u +%Y-%m-%d)" >> $GITHUB_STEP_SUMMARY
          echo "**Total Alerts:** ${{ needs.analyze.outputs.total_alerts }}" >> $GITHUB_STEP_SUMMARY
          echo "**Auto-PR Candidates:** ${{ needs.analyze.outputs.candidate_count }}" >> $GITHUB_STEP_SUMMARY
          echo "**Dry Run:** ${{ inputs.dry_run || 'false' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ðŸ“Š Top 10 Priority Alerts" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Package | Severity | CVE | ROI | Update | Auto-PR? |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|:--------:|-----|----:|--------|:--------:|" >> $GITHUB_STEP_SUMMARY
          
          jq -r '.[:10][] | "| \(.package) | \(.severity) | \(.cve_id // "N/A") | \(.roi) | \(.update_type) | \(if .safe_for_auto_pr then "âœ…" else "âŒ" end) |"' \
            /tmp/prioritized_alerts.json >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ¤– Auto-PR Candidates" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f /tmp/auto_pr_candidates.json ]; then
            count=$(jq 'length' /tmp/auto_pr_candidates.json)
            if [ "$count" -gt 0 ]; then
              echo "| Package | Current | Patched | ROI | Status |" >> $GITHUB_STEP_SUMMARY
              echo "|---------|---------|---------|----:|--------|" >> $GITHUB_STEP_SUMMARY
              jq -r '.[] | "| \(.package) | \(.current_version) | \(.patched_version) | \(.roi) | PR Created |"' \
                /tmp/auto_pr_candidates.json >> $GITHUB_STEP_SUMMARY
            else
              echo "No candidates met the criteria for auto-PR." >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*ROI = (CVSS Ã— EPSS Ã— 100 Ã— Scope) / Effort*" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Auto-PR Criteria:**" >> $GITHUB_STEP_SUMMARY
          echo "- ROI â‰¥ ${{ inputs.min_roi || 100 }}" >> $GITHUB_STEP_SUMMARY
          echo "- Patch or minor version update only" >> $GITHUB_STEP_SUMMARY
          echo "- npm ecosystem" >> $GITHUB_STEP_SUMMARY
